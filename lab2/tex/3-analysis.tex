\section{Аналитический раздел \hfill}
\vspace{\baselineskip}

\numberwithin{equation}{subsection}

\subsection{Стандартный алгоритм умножения матриц}

Пусть даны две прямоугольные матрицы $A[M \times N]$ и $B[N \times Q]$:
$$
A = 
\begin{bmatrix} 
	a_{11} & a_{12} & \cdots & a_{1n} \\
	a_{21} & a_{22} & \cdots & a_{2n} \\ 
	\vdots & \vdots & \ddots & \vdots \\ 
	a_{m1} & a_{m2} & \cdots & a_{mn}
\end{bmatrix}
B =   
\begin{bmatrix} 
	b_{11} & b_{12} & \cdots & b_{1q} \\
	b_{21} & b_{22} & \cdots & b_{2q} \\ 
	\vdots & \vdots & \ddots & \vdots \\ 
	b_{n1} & b_{n2} & \cdots & b_{nq}
\end{bmatrix}
$$

Тогда матрица $C[M \times Q]$ -- произведение матриц $A$ и $B$:
$$
C = 
\begin{bmatrix} 
	c_{11} & c_{12} & \cdots & c_{1q} \\
	c_{21} & c_{22} & \cdots & c_{2q} \\ 
	\vdots & \vdots & \ddots & \vdots \\ 
	c_{m1} & c_{m2} & \cdots & c_{mq}
\end{bmatrix},
$$
в которой каждый элемент вычисляется по формуле: 
\begin{equation}
	c_{ij} = \sum_{k=1}^n a_{ik}b_{kj}, ~(i=1, 2, \ldots m;j=1, 2, \ldots q)~~
\end{equation}

Стандартный алгоритм реализует формулу умножения матриц в прямом виде. Для каждого элемента подсчитывается значение независимо от других вычислений.

Преимущество этого алгоритма состоит в простоте реализации, а также в отсутствии дополнительных затрат на память. 
Платой за столь короткую реализацию алгоритма является высокое время выполнения.
Для матриц размером 500х500 время выполнения уже выше трех секунд. Одним из способов уменьшения времени выполнения является использование более эффективного алгоритма умножения матриц -- алгоритма Винограда \cite{article_matrix_4}.


\subsection{Алгоритм умножения матриц Винограда}

Заметим, что каждый элемент в результате умножения двух матриц представляет собой скалярное произведение соответствующих строки и столбца исходных матриц.
Кроме того, такое умножение допускает предварительную обработку, позволяющую часть работы выполнить заранее.

Рассмотрим два вектора $V = (v_1, v_2, v_3, v_4)$ и $W = (w_1, w_2, w_3, w_4)$.
Их скалярное произведение равно: $V \cdot W = v_1w_1 + v_2w_2 + v_3w_3 + v_4w_4$, что эквивалентно следующей записи:
\begin{equation}
	\label{for:new}
	V \cdot W = (v_1 + w_2)(v_2 + w_1) + (v_3 + w_4)(v_4 + w_3) - v_1v_2 - v_3v_4 - w_1w_2 - w_3w_4
\end{equation}

Кажется, что второе выражение задает больше работы, чем первое: вместо четырех умножений мы насчитываем их шесть, а вместо трех сложений -- десять. Менее очевидно, что выражение в правой части последнего равенства допускает предварительную обработку: его части можно вычислить заранее и запомнить для каждой строки первой матрицы и для каждого столбца второй. На практике это означает, что над предварительно обработанными элементами нам придется выполнять лишь первые два умножения и последующие пять сложений, а также дополнительно два сложения \cite{article_matrix_3}.

В случае нечетного размера $n$ начальной матрицы следует произвести еще одну операцию --- добавление произведения последних элементов соответствующих строк и столбцов.

\subsection*{Вывод}

В данном разделе были рассмотрены идеи, лежащие в основе алгоритмов умножения матриц: стандартного и алгоритма Винограда.
